---
title : "[Kotlin IN ACTION] 02장 코틀린 기초1"
excerpt: "코틀린 정주행2"

categories :
  - Kotlin

toc: true
toc_sticky: true
last_modified_at: 2022-02-05
---

![field.jpg](/assets/images/field.jpg?raw=true)

2장에서는 모든 프로그램에서 필수 요소인 변수, 함수, 클래스등을 코틀린에서 어떻게 선언하는지 살펴보고 프로퍼티라는 개념을 배운다.

그 후 코틀린의 여러 제어 구조를 배운다. 대부분의 코틀린 제어 구조는 자바와 비슷 하지만 몇 가지 중요한 개선이 이뤄졌다.

그 다음 스마트 캐스트에 대해 설명한다. 스마트 캐스트는 타입 검사와 타입 캐스트, 타입 강제 변환을 하나로 엮은 기능이다.

마지막으로 예외 처리를 살펴본다.

## 2.1 기본 요소: 함수와 변수

모든 프로그램을 구성하는 기본 단위인 함수와 변수를 살펴본다.

코틀린에서 타입 선언을 생략해도 된다는 사실을 보고, 코틀린이 어떻게 변경 가능한 데이터보다 변경할 수 없는 불변 데이터 사용을 장려하는지 배운다.

### 2.1.1 Hello, World!

'Hello, World!'를 찍는 프로그램으로 시작해보자.

```kotlin
fun main(args: Array<String>) {
    println("Hello, world!")
}
```

간단한 코드에서 코틀린의 여러 특성을 발견할 수 있다.

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위수준에 정의할 수 있다. (자바와 달리) 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- 배열도 일반적인 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열처리를 위한 문법이 따로 존재하지 않는다.
- System.out.println 대신에 println이라고 쓴다. 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공한다.
- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 세미콜론(;)을 붙이지 않아도 좋다.

이제 함수 선언 문법을 좀 더 살펴보자

### 2.1.2 함수

이제 결과를 반환하는 함수를 보자

함수 선언은 fun 키워드로 시작한다.

fun 다음에는 함수 이름이 온다.

함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다.

함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데,

괄호와 반환 타입 사이를 콜론(:)으로 구분해야 한다.

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

코틀린 if는 (값을 만들어내지 못하는)문장이 아니고 결과를 만드는 식(expression)이라는 점이 흥미롭다.

**💡 문(statement)과 식(expression)의 구분**  
코틀린에서 if는 식이지 문이 아니다.

식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.

자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다. 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있다.

반면 대입문은 자바에서는 식이였으나 코틀린에서는 문이 됐다.

**식이 본문인 함수**  
조금 전에 살펴본 함수를 더 간결하게 표현할 수도 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라 부르고, 등호와 식으로 이뤄진 함수를 **식이 본문인 함수**라고 부른다.

💡 인텔리J 아이디어 팁

인텔리J 아이디어는 이 두 방식의 함수를 서로 변환하는 메뉴가 있다.

각각은 '식 본문으로 변환(Convert to expression body)'과 '블록 본문으로 변환(Convert to block body)'이다.

코틀린에서는 식이 본문인 함수가 자주 쓰인다. 그런 함수의 본문 식에는 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다.

반환 타입을 생략하면 함수를 더 간략하게 만들 수 있다.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

코틀린은 정적 타입 지정 언어이므로 컴파일 시점에모든 식의 타입을 지정하는게 맞지만 **식이 본문인 함수**의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 함수 반환 타입으로 정해준다.

이제 변수 선언 문법에 대해 살펴보자.

### 2.1.3 변수

자바에서는 변수를 선언할 때 타입이 맨 앞에 온다.

코틀린에서는 타입 지정을 생략하는 경우가 흔하다.

```kotlin
val answer = 42 // 타입 생략
val answer: Int = 42 // 타입 지정
```

초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야한다.

```kotlin
val answer: Int
answer = 42
```

**변경 가능한 변수와 변경 불가능한 변수**  
변수 선언 시 사용하는 키워드는 다음과 같은 2가지가 있다.

- val(값을 뜻하는 value에서 유래) - 변경 불가능한(immutable) 참조를 저장하는 변수다. 자바로 말하자면 final 변수에 해당한다.
- var(변수를 뜻하는 variable에서 유래) - 변경 가능한(mutable) 참조다. 자바의 일반 변수에 해당한다.

기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하라.

변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.

val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다. 하지만 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

```kotlin
val message: String
if (canPerformOperation()) {
    message = "Success"
    // ... 연산을 수행한다. 
} else {
    message = "Failed"
}
```

val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.

```kotlin
val languages = arrayListOf("Java") //불변 참조를 선언한다.
languages.add("Kotlin") // 참조가 가리키는 객체 내부를 변경한다.
```

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.

```kotlin
var answer = 42
answer = "no answer" // 컴파일 오류 발생
```

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다.

```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name")
}
```

$ 문자를 문자열에 넣고 싶으면 println("\$x")와 같이 \를 사용해 $를 이스케이프시켜야 한다.

문자열 템플릿 안에 사용할 수 있는 대상은 간단한 변수 이름만으로한정되지 않는다.

복잡한 식도 중괄호({ })로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.

```kotlin
fun main(args: Array<String>) {
    if(args.size > 0){
        println("Hello, ${args[0]}!)
    }
}
```

중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다.

```kotlin
fun main(args: Array<String>) {
    println("Hello, ${ if(args.size > 0) args[0] else "someone" }!)
}
```

## 2.2 클래스와 프로퍼티

코틀린을 활용하면 더 적은 양의 코드로 클래스와 관련 있는 대부분의 작업을 수행할 수 있다는 사실을 차차 알게 될 것이다.

이전에 만든 자바 Person 클래스를 다시 살펴보자.

```java
public class Person {
    private final String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}
```

자바-코틀린 변환기를 써서 방금 본 Person 클래스를 코틀린으로 변환해보자.

```kotlin
class Person(val name: String)
```

자바로 코틀린으로 변환한 결과, public 가시성 변경자가 사라졌음을 확인하였다. 코틀린의 기본 가시성은 public이므로 이런 경우 변경자를 생략해도 된다.

### 2.2.1 프로퍼티

클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.

자바에서는 필드와 접근자(getter, setter)를 한데 묶어 프로퍼티라고 부르며, 프로퍼티라는 개념을 활용하는 프레임워크가 많다.

코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다.

```kotlin
class Person(
    val name: String, // 읽기 전용 프로퍼티로, 코틀린은 (비공개) 필드와 필드를 읽는 단순한 (공개) 게터를 만들어 낸다. 
    
    var isMarried: Boolean // 쓸 수 있는 프로퍼티로, 코틀린은 (비공개)필드, (공개) 게터/세터를 만들어 낸다. 
)
```

💡 프로퍼티 팁

자바에서는 getName과 setName이라는 접근자를 제공하는 자바 클래스를 코틀린에서 사용할 때는 name이라는 프로퍼티를 사용할 수 있다.

### 2.2.2 커스텀 접근자

이번 절에서는 프로퍼티의 접근자를 직접 작성하는 방법을 보여준다.

```kotlin
class Rectangle (val height: Int, val width: Int) {
    val isSquare: Boolean
        get() { //프로퍼티 게터 선언
            return height == width
        }
}
```

직사각형이 정사각형인지를 별도의 필드에 저장할 필요가 없다. 사각형의 너비와 높이가 같은지 검사하면 정사각형 여부를 그때그때 알 수 있다.

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다. 최상위 함수는 그 이름을 써서 임포트할 수 있다.

```kotlin
package geometry.example

import geometry.shapes.createRandomRectangle // 이름으로 함수 임포트하기

fun main(args: Array<String>) {
    println(createRandomRectangle().isSquare) // "true"가 아주 드물게 출력된다. 
}
```

코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다.

코틀린에서는 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계없다.

따라서 원하는 대로 소스코드를 구성할 수 있다.

## 참조

> 드미트리 제메로프 · 스베트라나 이사코바, 『Kotlin IN ACTION』, 오현석 옮김, 에이콘(2017), P59-77.
>